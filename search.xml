<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Yarn安装与使用详细介绍]]></title>
      <url>https://akuraSnow.github.io/2018/07/20/yarn/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 Node 生态系统中，依赖通常安装在项目的 <code>node_modules</code> 文件夹中。然而，这个文件的结构和实际依赖树可能有所区别，因为重复的依赖可以合并到一起。<code>npm</code> 客户端把依赖安装到 <code>node_modules</code> 目录的过程具有不确定性。这意味着当依赖的安装顺序不同时，<code>node_modules</code> 目录的结构可能会发生变化。这种差异可能会导致类似<font color="red">“我的电脑上可以运行，别的电脑上不行”</font>的情况，并且通常需要花费大量时间定为与解决。</p>
<blockquote>
<p>有时候就会遇到这种情况，完整可运行的项目上传到 git 上，别人 pull 下来以后，npm install 会报错。</p>
</blockquote>
<p><a href="https://github.com/yarnpkg/yarn" target="_blank" rel="external">Yarn</a> 一开始的主要目标是解决由于语义版本控制而导致的 npm 安装的不确定性问题。虽然可以用 <code>npm shrinkwrap</code> 来实现可预测的依赖关系树，但它并不是默认选项，而是取决于所有的开发人员指导并启用这个选项。</p>
<a id="more"></a>
<blockquote>
<p>npm 5+ 以后的版本加入了 package-lock.json 可以用来锁版本，package-lock.json 的名字，一看就懂，更清楚，但是不向后兼容。</p>
<p>npm-shrinkwrap.json 向后兼容 npm 2-4。</p>
</blockquote>
<p><font color="red">举个例子：</font><br>npm 对包引入顺序也十分的敏感，比如在一个空项目里执行以下命令：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install globule@<span class="number">0.1</span><span class="number">.0</span> -S</span><br><span class="line">npm install babel-generator@<span class="number">6.19</span><span class="number">.0</span> -S</span><br><span class="line">npm install babel-helper-define-map@<span class="number">6.18</span><span class="number">.0</span> -S</span><br></pre></td></tr></table></figure></p>
<p>我们这里安装了 3 个包都依赖于 lodash，不过 globule 依赖 lodash@1.0.3，另外另个依赖 lodash@4.x。<br>现在目录依赖结构如下：<br><img src="https://img-blog.csdn.net/20180824142908356?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feXVkb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="npm-package"></p>
<p>这是假设我们在项目里使用 lodash，但是忘记重新安装 lodash<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lodash = <span class="built_in">require</span>(<span class="string">'lodash'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(lodash.VERSION)  <span class="comment">// v1.0.3</span></span><br></pre></td></tr></table></figure></p>
<p>另一个同事获取项目代码，执行 <code>npm install</code>，这时的目录依赖结构里面，第一层依赖的 lodash 变成了 4.x 版本，这样就造成了依赖版本不一致的问题。而 yarn 则会保证无论怎样引入的顺序，目录依赖结构都是一致的，确保不会发生这样的BUG。</p>
<h1 id="什么是-Yarn"><a href="#什么是-Yarn" class="headerlink" title="什么是 Yarn"></a>什么是 Yarn</h1><p>Yarn 就是一个类似于 npm 的包管理工具，它是由 facebook 推出并开源。</p>
<p>与 npm 相比，yarn 有着众多的优势，主要的优势在于：速度快、离线模式、版本控制。</p>
<h2 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h2><p>npm 会等一个包完全安装完才跳到下一个包，但 yarn 会并行执行包，因此速度会快很多。</p>
<p>Yarn 会缓存它下载的每个包，所以无需重复下载。它还能并行化操作以最大化资源利用率，安装速度之快前所未有。</p>
<h2 id="离线模式"><a href="#离线模式" class="headerlink" title="离线模式"></a>离线模式</h2><p>之前安装过的包会被保存进缓存目录，以后安装就直接从缓存中复制过来，这样做的本质还是会提高安装下载的速度，避免不必要的网络请求。</p>
<h2 id="可靠可确定性"><a href="#可靠可确定性" class="headerlink" title="可靠可确定性"></a>可靠可确定性</h2><p>保证各平台依赖的一致性</p>
<h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><p>力求网络资源最大利用化，让资源下载完美队列执行，避免大量的无用请求，下载失败会自动重新请求，避免整个安装过程失败</p>
<h2 id="扁平化模式"><a href="#扁平化模式" class="headerlink" title="扁平化模式"></a>扁平化模式</h2><p>对于不匹配的依赖版本的包创立一个独立的包，避免创建重复的。<br>对于多个包依赖同一个子包的情况，yarn 会尽量提取为同一个包，防止出现多处副本，浪费空间。</p>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>npm 用下来比较强的一个痛点就是：当包的依赖层次比较深时，版本控制不够精确。会出现相同 package.json，但不同人的电脑上安装出不同版本的依赖包，出现类似<font color="red">“我的电脑上可以运行，别的电脑上不行”</font>的 bug 很难查找。你可以使用 <a href="https://docs.npmjs.com/cli/shrinkwrap" target="_blank" rel="external">npm-shrinkwrap</a> 来实现版本固化，版本信息会写入 npm-shrinkwrap.json 文件中，但它毕竟不是 npm 的标准配置。</p>
<p>而 yarn 天生就能实现版本固化。会生成一个类似 npm-shrinkwrap.json 的 yarn.lock 文件，而文件内会描述包自身的版本号，还会锁定所有它依赖的包的版本号：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"@babel/code-frame@7.0.0-beta.47"</span>:</span><br><span class="line">  version <span class="string">"7.0.0-beta.47"</span></span><br><span class="line">  resolved <span class="string">"https://registry.yarnpkg.com/@babel/code-frame/-/code-frame-7.0.0-beta.47.tgz#d18c2f4c4ba8d093a2bcfab5616593bfe2441a27"</span></span><br><span class="line">  dependencies:</span><br><span class="line">    <span class="string">"@babel/highlight"</span> <span class="string">"7.0.0-beta.47"</span></span><br></pre></td></tr></table></figure></p>
<p>yarn.lock 存储着你的每个包的确切依赖版本，能确保从本地开发到生产环境，所有机器上都有精确相同的依赖版本。</p>
<h2 id="其他关于-Yarn-的介绍"><a href="#其他关于-Yarn-的介绍" class="headerlink" title="其他关于 Yarn 的介绍"></a>其他关于 Yarn 的介绍</h2><p>我们在使用 Yarn 时，依然要访问 npm 仓库，但 Yarn 能够更快速地安装软件包和管理依赖关系，并且可以在跨机器或者无网络的安全环境中保持代码的一致性。</p>
<h1 id="Yarn-安装"><a href="#Yarn-安装" class="headerlink" title="Yarn 安装"></a>Yarn 安装</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>在 Yarn 中文网可以找到 window 下的三种安装方法：</p>
<p><img src="https://img-blog.csdn.net/20180824120236673?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feXVkb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="yarn-install"></p>
<p>不过我觉得这三种方法都不好用，快速好用的安装方法应该还是使用 npm 来安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure></p>
<p>关于为什么使用 <code>-g</code>，以及 <code>-g</code> 会带来哪来影响，这个可以看我的这篇文章：<a href="https://neveryu.github.io/2017/04/10/npm/" target="_blank" rel="external">npm详细介绍</a>，里面详细介绍了为什么要使用 <code>-g</code>，以及 <code>-g</code> 的作用。</p>
<h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure>
<p>如果有报： <code>Please try running this command again as root/Administrator.</code>，可能就是权限不足，因此你需要切换到最高权限去执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line">npm install yarn -g</span><br></pre></td></tr></table></figure></p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用另一种初始化脚本的方法，可能就会比较简单一些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- -L https://yarnpkg.com/install.sh | bash</span><br></pre></td></tr></table></figure></p>
<h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>如果你的电脑上面已经安装了 Homebrew 的话，你可以通过 Homebrew 包管理器安装 Yarn<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install yarn</span><br></pre></td></tr></table></figure></p>
<h1 id="Yarn-换源"><a href="#Yarn-换源" class="headerlink" title="Yarn 换源"></a>Yarn 换源</h1><p>Yarn 源仓库包下载不稳定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查看 yarn 配置</span><br><span class="line">yarn config get registry</span><br><span class="line">或者</span><br><span class="line">yarn config list</span><br><span class="line"></span><br><span class="line">&gt; registry: &apos;https://registry.yarnpkg.com&apos;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装淘宝镜像</span><br><span class="line">yarn config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h1 id="Yarn-常用命令"><a href="#Yarn-常用命令" class="headerlink" title="Yarn 常用命令"></a>Yarn 常用命令</h1><ul>
<li><code>npm install</code> === <code>yarn</code>  —— install安装是默认行为</li>
<li><code>npm install taco --save</code> === <code>yarn add taco</code>  —— taco包立即被保存到 <code>package.json</code> 中。</li>
<li><code>npm uninstall taco --save</code> === <code>yarn remove taco</code></li>
<li><code>npm install taco --save-dev</code> === <code>yarn add taco --dev</code></li>
<li><code>npm update --save</code> === <code>yarn upgrade</code></li>
</ul>
<p>-</p>
<ul>
<li><code>npm install taco@latest --save</code> === <code>yarn add taco</code></li>
<li><code>npm install taco --global</code> === <code>yarn global add taco</code>  —— 一如既往，请谨慎使用 global 标记。</li>
</ul>
<blockquote>
<p>注意：使用yarn或yarn install安装全部依赖时是根据package.json里的”dependencies”字段来决定的</p>
</blockquote>
<p>-</p>
<ul>
<li><code>npm init</code> === <code>yarn init</code></li>
<li><code>npm init --yes/-y</code> === <code>yarn init --yes/-y</code></li>
<li><code>npm link</code> === <code>yarn link</code></li>
<li><code>npm outdated</code> === <code>yarn outdated</code></li>
<li><code>npm publish</code> === <code>yarn publish</code></li>
<li><code>npm run</code> === <code>yarn run</code></li>
<li><code>npm cache clean</code> === <code>yarn cache clean</code></li>
<li><code>npm login</code> === <code>yarn login</code></li>
<li><code>npm test</code> === <code>yarn test</code></li>
</ul>
<h2 id="Yarn-独有的命令"><a href="#Yarn-独有的命令" class="headerlink" title="Yarn 独有的命令"></a>Yarn 独有的命令</h2><ul>
<li><code>yarn licenses ls</code>  —— 允许你检查依赖的许可信息</li>
<li><code>yarn licenses generate</code>  —— 自动创建依赖免责声明 license</li>
<li><code>yarn why taco</code>  —— 检查为什么会安装 taco，详细列出依赖它的其他包</li>
<li><code>yarn why vuepress</code>  —— 检查为什么会安装 vuepress，详细列出依赖它的其他包</li>
</ul>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>Yarn 除了让安装过程变得更快与更可靠，还添加了一些额外的特性，从而进一步简化依赖管理的工作流。</p>
<ul>
<li>同时兼容 <code>npm</code> 与 <code>bower</code> 工作流，并支持两种软件仓库混合使用</li>
<li>可以限制已安装模块的协议，并提供方法输出协议信息</li>
<li>提供一套稳定的共有 JS API，用于记录构建工具的输出信息</li>
<li>可读、最小化、美观的 CLI 输出信息</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Yarn </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【转】为什么我们放弃了 Zepto]]></title>
      <url>https://akuraSnow.github.io/2017/02/14/why-we-dropped-zepto/</url>
      <content type="html"><![CDATA[<!-- <img src="http://i2.muimg.com/567571/fae45a374015a1c2.png" alt="summary-img-src-zepto"> -->
<a id="more"></a>
<blockquote>
<p><a href="http://foundation.zurb.com/" target="_blank" rel="external">Foundation</a> 是 <a href="http://zurb.com/" target="_blank" rel="external">Zurb</a> 公司开源的一套前端框架，和 <a href="http://www.bootcss.com/" target="_blank" rel="external">Bootstrap</a> 类似。</p>
</blockquote>
<p>在漆深的洞中，聪明、强壮的雪人（雪人 – Yeti – 是 Foundation 框架的吉祥物，这里其实是暗指 Foundation 框架）听到人们的询问“Zepto 去哪儿了？”。</p>
<p>回顾 Foundation 版本 4 开发时，我们考虑采用 Zepto 库（jQuery 可选），主要是由于 Zepto 体积小、加载速度快。</p>
<p>随着时间的推移，我们发现文件体积的大小根本和执行效率没有任何比例关系。当然，必须承认，Zepto 下载的确很快。但是，一旦下载到浏览器之后，它并不像 jQuery 一样执行速度快。并且，很多第三方插件都依赖 jQuery，不支持 Zepto – 实际上，我们发现某些第三方插件和 Zepto 有冲突。</p>
<p>对于我们来讲，维护多套代码很不容易。例如，Zepto 缺少合适的高度计算函数，这让某些栅格（grid）的计算变得很困难。</p>
<p>为了解决这些问题，我们发现解决办法其实极其简单：基于 jQuery 2 构建 Foundation 版本 5。除了获得更好的执行速度和广泛的业界支持外，jQuery 2 的文档更优秀、支持也同样更好。jQuery 的 API 在各个版本是兼容的。</p>
<p>等一等，为了把问题讲清楚，我们还是先假定 Zepto 的执行速度可能比 jQeury 快。我们不希望犯同样的错误，因此，我们将 Zepto 和 jQuery 2 进行对比测试，测试结果是：<a href="http://jsperf.com/zepto-vs-jquery-2013/25" target="_blank" rel="external">jQuery 2 每秒执行的操作次数比 Zepto 多</a>。这让 Foundation 版本 5 的执行效率更高，同时让所有用户感受到更好的体验。</p>
<p>最后，我们希望帮助大家更快速地设计优秀的产品 – 这次，我们的一点儿改变，让 Foundation 这个前端框架的速度得到大幅提升！</p>
<h2 id="译者总结："><a href="#译者总结：" class="headerlink" title="译者总结："></a>译者总结：</h2><p>在开源的世界中，充斥着大量的开源项目，但是，只有少部分的开源项目为广大开发者所熟知并积极使用。一个好的开源项目必须有一个强大的社区和一批积极的贡献者，jQuery 就是其中一个幸运儿。</p>
<p>原文地址：<a href="http://zurb.com/article/1293/why-we-dropped-zepto" target="_blank" rel="external">http://zurb.com/article/1293/why-we-dropped-zepto</a></p>
]]></content>
      
        <categories>
            
            <category> 综合 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zepto </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
